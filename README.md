# Algorithms & Data Structures

I never took a Computer Science course in university since my major was
Philosophy and my goal was to be a lawyer. I dropped out after two years
Phew, glad I dodged that bullet!

During my travails as a self-taught programmer I have sometimes felt
unprepared to solve certain problems such as implementing a DB or antiquated
whiteboard interviews. Lately, my curiosity is ever consumed by distributed
systems which frequently use algorithms and data structures foreign to me.

I want to fill the void in my education as a professional, because choking
during whiteboard interviews sucks, an unrelenting desire to make my life
miserable dealing with failure writing distributed systems. Really, I had
no choice given my obsession with learning everything I can to improve
as a professional programmer.

## Goals

I created this repository to implement common algorithms/data structures
with the following goals:

1. Have *fun*.
2. Learn, learn, learn. The code in this repository is solely for learning
   and self-practice only; it is not intended for production.
3. Read as much as I can stomach using varied & multiple
   [resources](#wiki-resources) so that I may fully understand the material
   by learning from myriad teachers. This can be used successfully as
   [distributed practice](http://digitalpromise.org/2015/02/07/five-learning-strategies-that-work/#distributedpractice),
   a highly effective learning technique.
4. Implement common/interesting/fundamental algorithms/data structures.
   This, of course, is [practice testing](http://digitalpromise.org/2015/02/07/five-learning-strategies-that-work/#practicetesting),
   another highly effective learning technique when the stakes are low.
5. Complete 4. in both Haskell & Go. Why? Well, a friend once called me
   a "try hard." It's true.

## TOC

* [Why Go?](#wiki-Why Go?)
* [Why Haskell?](#wiki-Why Haskell?)
* [Data Structures](#wiki-Data Structures)
  * [Go](go/data_structures)
    * [SinglyLinkedList](go/data_structures/list.go)
    * [Queue](go/data_structures/queue.go)
    * [Stack](go/data_structures/stack.go)
    * [Set](go/data_structures/set.go)
  * [Haskell](haskell/data_structures)
* [Algorithms](#wiki-Algorithms)
  * [Go](go/algorithms)
    * [Fisher-Yates Shuffle](go/algorithms/basics.go)
    * [In-place Reverse](go/algorithms/basics.go)
    * [Binary Search](go/algorithms/basics.go)
  * [Haskell](haskell/algorithms)
    * [Fisher-Yates Shuffle](haskell/algorithms/basics.hs)
    * [In-place Reverse](haskell/algorithms/basics.hs)
    * [Binary Search](haskell/algorithms/basics.hs)

## Why Go?

I chose Go for reasons which FP advocates may disagree; however, what's most
important is fidelity.

## Why Haskell?

I chose Haskell for reasons which FP advocates may disagree; however,
what's most important is that we'll never be happy.

## Resources

No worries, I'm not using affiliate links.

* [Introduction to Algorithms, 3rd Edition](http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen-ebook/dp/B007CNRCAO/ref=dp_kinw_strp_1)
* [Algorithms, 4th Edition](http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X)
* [Khan Academy: Algorithms](https://www.khanacademy.org/computing/computer-science/algorithms)
* [Purely Functional Data Structures](http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504)
* [Wikibooks Data Structures](https://en.wikibooks.org/wiki/Data_Structures)
* [Scalacaster by @vkostyukov](https://github.com/vkostyukov/scalacaster)

## Thank You
